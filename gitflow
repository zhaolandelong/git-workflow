#!/bin/bash
# Version: 1.0.0
# Edit By: zhaolandelong <landelong.zhao@tusimple.ai>
# Dependencies:
# - git
# - gh(https://cli.github.com/)
# Notice: Run "chmod +x ./gitflow" in cmd if this script not work

# TODO:
# 1. CHANGELOG optimize
# 2. gh release optimize

set -e

# Define branch
deployBR="master"
releaseBR="release"
developBR="develop"
initVer=$(git ls-remote --tags origin | awk '/\^\{\}/{}END{print $2}' | sed "s/.*\/\([0-9\.]*\).*/\1/g")

doMerge() {
  mergeType=$1
  sourceBR=$2
  targetBR=$3
  echo -e "\n\033[0;34m===== $sourceBR $mergeType $targetBR start =====\033[0m\n"
  git checkout $targetBR && git pull -r
  git checkout $sourceBR && git fetch -p
  if [ $(git branch -r | grep ${sourceBR}$) ]; then
    git pull -r
  fi
  git $mergeType $targetBR
  if [ $mergeType == "merge" ]; then
    git push -u origin $sourceBR
  else
    git push -u origin $sourceBR --force-with-lease
  fi
  echo -e "\n\033[0;32m===== $sourceBR $mergeType $targetBR finish =====\033[0m\n"
}

doChangelog() {
  sourceBR=$1
  targetBR=$2
  git log --pretty=format:"- %cd %h - %s" $sourceBR...$targetBR --date=format:"%m/%d %H:%M" >CHANGELOG.md
}

# SIDE EFFECTS
# Usage:
# version="1.2.3"
# doVersion version patch
# echo $version # 1.2.4
doVersion() {
  eval "ver=\$$1"

  IFS=. read -r major minor patch <<EOF
$ver
EOF

  case "$2" in
  patch) tag="$major.$minor.$((patch + 1))" ;;
  major) tag="$((major + 1)).0.0" ;;
  *) tag="$major.$((minor + 1)).0" ;;
  esac

  eval "$1=$tag"
}

# SIDE EFFECTS
doUpdateVersionAndPR() {
  sourceBR=$1
  targetBR=$2
  versionType=$3
  baseVerParam=$4

  version=""
  eval "version=\$$baseVerParam"

  git checkout $sourceBR && git pull -r
  doVersion version $versionType
  doChangelog $sourceBR $targetBR
  git push
  git tag $version && git push origin $version

  prStat=$(gh pr list -s open | grep -wc $sourceBR | xargs)
  if [ $prStat -eq 0 ]; then
    gh pr create --title "RELEASE: ${version}" --body-file CHANGELOG.md --base $targetBR
  fi
  eval "$baseVerParam=$version"
}

doFinish() {
  type=$1
  sourceBR=$2

  case $type in
  "feature")
    gh pr merge $sourceBR -rd
    ;;
  "bugfix")
    gh pr merge $sourceBR -rd
    doMerge rebase $developBR $releaseBR
    ;;
  "hotfix")
    doUpdateVersionAndPR $sourceBR $deployBR patch initVer
    gh pr ready $sourceBR && gh pr merge $sourceBR -md
    gh release create $initVer --title $initVer --notes-file CHANGELOG.md
    doMerge rebase $releaseBR $deployBR
    doMerge rebase $developBR $releaseBR
    ;;
  "UAT")
    gh pr merge $sourceBR -r
    doMerge rebase $developBR $releaseBR
    ;;
  "DEPLOY")
    gh pr merge $sourceBR -r
    gh release create $initVer --title $initVer --notes-file CHANGELOG.md
    doMerge rebase $developBR $releaseBR
    ;;
  esac
}

doWorkflow() {
  type=$1
  method=$2
  sourceBR=$3

  targetBR=""
  label=""

  case $type in
  "feature")
    targetBR=$developBR
    label="enhancement"
    ;;
  "bugfix")
    targetBR=$releaseBR
    label="invalid"
    ;;
  "hotfix")
    targetBR=$deployBR
    label="bug"
    ;;
  "UAT")
    targetBR=$releaseBR
    ;;
  "DEPLOY")
    targetBR=$deployBR
    ;;
  esac

  case $method in
  "start")
    if [ $type == "UAT" -o $type == "DEPLOY" ]; then
      break
    fi
    git checkout $targetBR
    git pull -r
    git checkout -b $sourceBR
    ;;
  "submit")
    prStat=$(gh pr list -s open | grep -wc $sourceBR | xargs)

    if [ $type == "DEPLOY" ]; then
      doUpdateVersionAndPR $releaseBR $deployBR minor initVer
    else
      doMerge rebase $sourceBR $targetBR
      prBody=$(git log --pretty=format:"- %cd %h - %s" $sourceBR...$targetBR --date=format:"%m/%d %H:%M")
      if [ $prStat -eq 0 ]; then
        gh pr create --title "$sourceBR to $targetBR" --body "$prBody" --base $targetBR --label "$label"
      else
        gh pr edit --body "$prBody"
      fi
    fi
    ;;
  "finish")
    doFinish $type $sourceBR
    ;;
  esac
}

doCheck() {
  git fetch -p
  # branch check
  if [ $(git branch -r | grep -v "HEAD" | grep -Ewc " origin/($deployBR|$releaseBR|$developBR)") -ne 3 ]; then
    echo -e "\n\033[0;31mPlease create [$deployBR, $releaseBR, $developBR] branches and push them to origin first.\033[0m\n"
    exit
  fi
  # tag check
  if [ $(git ls-remote --tags origin | awk '{print $2}' | grep -Ec "^refs/tags/[0-9]+\.[0-9]+\.[0-9]+(\^\{\})?$") -eq 0 ]; then
    echo -e "\n\033[0;31mPlease create a SEMVER tag and push it to origin first.\neg: 1.0.0, 0.0.0\033[0m\n"
    exit
  fi
}

main() {
  type=$1
  name=$2
  method=$3
  branch=""

  doCheck

  # Auto fill the params if the branch name has "/"
  if [ ${#type} -eq 0 ]; then
    currentBranch=$(git rev-parse --abbrev-ref HEAD)
    split_index=$(expr index "$currentBranch" / | xargs)
    if [ $split_index -ne 0 ]; then
      tmpType=${currentBranch:0:split_index-1}
      tmpName=${currentBranch:split_index:${#currentBranch}}
      echo "Do you want to use current params?"
      echo "- Type: $tmpType"
      echo "- Name: $tmpName"
      select confirm in "yes" "no"; do
        if [ $confirm == "yes" ]; then
          type=$tmpType
          name=$tmpName
        fi
        break
      done
    fi
  fi

  # Fill $type
  if [ ${#type} -eq 0 ]; then
    echo "What's the type? (Notice: Admin Permission needed with UAT and DEPLOY)"
    select type in "feature" "bugfix" "hotfix" "UAT" "DEPLOY"; do
      echo "- Type: $type"
      break
    done
  fi

  # Fill $name
  if [ $type != "UAT" -a $type != "DEPLOY" -a ${#name} -eq 0 ]; then
    echo "What's the name (description for short. eg: btn-display-error)?"
    read name
    echo "- Name: $name"
  fi

  # Generate $branch
  case $type in
  "UAT")
    branch=$developBR
    ;;
  "DEPLOY")
    branch=$releaseBR
    ;;
  *)
    branch="$type/$name"
    ;;
  esac

  # Fill $method
  if [ ${#method} -eq 0 ]; then
    echo "What's the method?"
    echo "- start: Start a work and create a new branch"
    echo "- submit: Submit a PR"
    echo "- finish: Merge the PR after CR and delete branch"
    select method in "start" "submit" "finish"; do
      echo "- Method: $method"
      break
    done
  fi

  # Do workflow
  doWorkflow $type $method $branch
}

main $1 $2 $3
